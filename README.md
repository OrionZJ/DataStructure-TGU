# DataStructure-learning
To preserve some data structure I wrote.

# 知识点整理

[TOC]

# 第一章 绪论  

## 数据结构定义

- **数据结构** 是相互之间存在一种或多种特定关 系的数据元素的集合

- **数据元素** 是数据的基本单位

- **数据项** 是数据的不可分割的最小单位

# 数据逻辑结构的分类

**两空** 

- 线性结构

- 非线性结构

**三空** 

- 线性结构
- 树形结构
- 图状结构

**四空** 

- 集合
- 线性结构
- 树形结构
- 图状结构

## 两类物理存储方式及特点

## 时间复杂度（排序、分析算法）的计算

>频度：语句重复执行的次数

# 第二章 线性表 

## 线性表的定义

>n个数据元素的有限序列。

## 非空循环单链表的特点

>无须增加存储量，仅对表的链接方式稍作改变，即可使得表处理更加方便灵活。

## 判断空表

链表为空，`head->next == NULL`

循环链表为空时，头结点`head->next == head`

## 是否访问到尾元素

链表到尾元素，`p->next == NULL`

循环链表到尾元素，`p->next == head`

## 顺序表中插入、删除操作移动元素的个数

在第i个元素之前插入一个元素时，需将第n至第i（**共n-i+1个**）元素向后移动一个位置。

删除第i个元素时需将第i+1至第n（**共n-i个**）元素依次向前移动一个位置。

## 单链表的插入与删除操作时间复杂度计算

插入或删除元素时，平均移动表中一半元素，则表长为n的插入删除时间复杂度为**O(n)**。

## 双向循环链表插入结点操作



## 合并有序链表

时间复杂度**O(Length_a + Length_b)**

# 第三章 栈和队列

## 栈和队列的逻辑特性

- 栈：先进后出
- 队列：先进先出

## 顺序栈的出栈、入栈

> 若base的值为NULL，则表明栈结构不存在。

## 栈的常见应用

- 数制转换
- 行编辑程序
- 迷宫求解
- 表达式求值

## 循环顺序队列出队和入队操作时队首队尾指针变化

除队列头元素算法中的特殊情况：当队列中最后一个元素被删后队列尾指针也丢失了，因此需对队尾指针重新赋值

```c
Q.rear = Q.front
```

## 循环顺序队列有关判断

- 判队空

```c
Q.front == Q.rear
```

- 判队满

```c
(Q.rear + 1) % MAXQSIZE == Q.front
```

- 求队中元素个数

```c
num = (rear - front + MAXQSIZE) % MAXQSIZE
```

## 指针操作

- 入队后指针操作

```c
Q.rear = (Q.rear + 1) % MAXQSIZE
```

- 出队后指针操作

```c
Q.front = (Q.front + 1) % MAXQSIZE
```

## 给出front、rear指针，操作求值


# 第四章  串

## 串的定义

>由零个或多个字符组成的有限序列

>串中字符的数目n称为串的**长度**

## 空串和空格串的区别

>零个字符的串称为**空串**，它的长度为零

## 了解串的模式识别算法

> KMP算法－－最长相等前后缀

# 第五章 数组和广义表

## 数组和广义表的定义

## 二维数组按行（列）优先地址的计算

```
LOC(i, j) = LOC(0, 0) + (b2 * i + j)L
```

## 上三角矩阵按列（行）优先存放地址的计算

## 广义表的定义及求表头、表尾操作


# 第六章 树和二叉树  

## 树和二叉树的定义

- 树的结点：包含一个数据元素及若干指向其子树的分支
- 结点的度：结点拥有的子树数（该结点孩子的个数）
- 叶子（终端结点）：度为0的结点
- 树的度：树内各结点的度的最大值
- 树的深度（高度）：树中结点的最大层次

> 如果将树中结点的各子树看成从左至右是有次序的（即不能互换），则称该树为**有序树**，否则称为**无序树**。

- 树：无序树

- 二叉树：有序树

```
Q：二叉树是树吗？
A：不是。
```

## 完全二叉树

> 如果深度为k、由n个结点的二叉树中各结点能够与深度为k的顺序编号的满二叉树从1到n标号的结点相对应，则称这样的二叉树为完全二叉树。

## 满二叉树

> 一棵深度为k且由2k-1个结点组成的二叉树称为满二叉树

除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。

## 二叉树的五个性质

1. 在二叉树的第i层上至多有$$ 2 ^{i - 1}$$个结点 （i>=1）

2. 深度为k的二叉树至多有$$2^k - 1$$个结点（k>=1)

3. 对任何一棵二叉树，如果其终端结点数为n0，度为2的结点数为n2，则$$n0 ＝ n2 + 1$$（理解证明过程）

   - 终端结点数n0

   - 度为1的节点数n1

   - 度为2的节点数n2

   - 总共结点数n
     $$
     n = n0 + n1 + n2\\
     
     n = n1 + 2*n2 + 1
     $$
     

4. 具有n个结点的完全二叉树的深度为$$\lfloor \log_2n \rfloor + 1$$（理解log怎么来的）

##  二叉树的先序、中序、后序遍历



## 普通树结点个数、度、和分支数的关系



## 树和二叉树、森林和二叉树

- 树转二叉树

  1. 加线：在兄弟之间加一连线
  2. 抹线：对每个结点，除了其左孩子外，去除其与其余孩子之间的关系
  3. 旋转：以树的根结点为轴心，将整树顺时针转45°
  
- 森林转二叉树
  
  1. 将各棵树分别转换成二叉树
  2. 将每棵树的根结点用线相连
  3. 以第一棵树根结点为二叉树的根，再以根结点为轴心，顺时针旋转，构成二叉树型结构
  
- 遍历方法的对应关系

  > 森林的先序和中序遍历即为其对应二叉树的先序和中序遍历

  > 树的先根和后根遍历即为其对应二叉树的先序和中序遍历

## 二叉链表存储线索二叉树的空指针个数

> 在有n个结点的二叉链表中必定存在n+1个空链表

## 线索二叉树中序遍历方法

> 非终端结点的的后继是其右子树中最左下结点

> 结点若左链为线索，指示其前驱；否则前驱为其左子树中最右下结点

1. 找到序列中的第一个节点
2. 依次找到节点后继直至其后继等于其头结点为止

## Huffman树的特点

- 没有度为1的结点（每个非叶子结点都是由两个最小值的结点构成）
- n个叶子结点的哈夫曼树总共有2n-1个结点
- 哈夫曼树的任意非叶结点的左右子树交换后仍是哈夫曼树
- 对同一组权值{w1，w2，..}，存在不同构的两个哈夫曼树，但是它们的总权值相等。

## 构造方法

1. 根据给定的n个权值 ，构造n棵只有一个根结点的二叉树， n个权值分别是这些二叉树根结点的权。设F是由这n棵二叉树构成的集合
2. 在F中选取两棵根结点树值最小的树作为左、右子树，构造一颗新的二叉树，置新二叉树根的权值等于左、右子树根结点权值之和
3. 从F中删除这两颗树，并将新树加入F
4. 重复 2、3，直到F中只含一颗树为止

## 利用Huffman树求Huffman编码的方法

> 左0右1构建

#   第七章 图    

  图的定义、结点度的计算。无向图的连通分量的概念，图的深度和广度优先遍历方法；图(或网)的存储（邻接表、邻接矩阵）方法及特点；最小生成树的概念及求法，拓扑排序和关键路径求法。
  第九章 查找 
  顺序表查找的平均查找长度，二分（折半）查找的过程及查找失败时的比较次数，动态查找和静态查找的概念，二叉排序树的平均查找长度、平衡二叉树的定义及构造，哈希表的构造（除留余数法）、解决冲突的方法（线性探测再散列法、二次探测再散列法），哈希查找的查找成功时平均查找长度(ASL)的计算。
  第十章 排序  
  排序的分类，冒泡排序、直接插入排序、堆排序、希尔排序、简单选择排序、快速排序的排序过程；堆排序的适用情况；各类排序算法的稳定性及时间和空间复杂度。